\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
\hypersetup{
colorlinks = true,
urlcolor = blue, % color of external links using \href
linkcolor= blue, % color of internal links
citecolor= blue, % color of links to bibliography
filecolor= blue, % color of file links
}
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=haskell,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=3
}


\title{CPSC-354 Report}
\author{Connor Cowher \\ Chapman University}

\date{12/21/2021}

\begin{document}

\maketitle

\begin{abstract}
This report will dive into the aspects of learning Haskell and the functions to know when creating a project. Haskell is much different from other programming languages like Java and C/C++ and requires a more extensive knowledge to perfect. This software has an extensive Prelude, similar to a library, that should be looked into in order to better utilize the functions for your program. Haskell is a great introductory language for new programmers since it is its own unique assembly type language. Although you do not need a masters degree in mathematics, it would be beneficial to have some exposure in advanced arithmetic. Haskell is both as difficult and simple as you make it. As long as you study, understand, and make good decisions while programming, Haskell will be a great platform for you to utilize. I will also be explaining how to make a project in this language, while showing some example code in Haskell. Coding in this language seems very basic and very few characters are required per line, for the most part. A very useful topic to know and have in your back pocket would be lambda calculus. This version of mathematics is very helpful in computer calculation logic, a major aspect of Haskell. While helping out in logic, another helpful aspect of lambda calculus is its ability to simulate on a Turing machine. Though limited to Linux systems, a virtual machine, or virtual box application, can simulate an apple OS while on a windows machine...
\clearpage
\end{abstract}

\tableofcontents
\clearpage

\section{Introduction}\label{intro} 

Haskell is a programming language where it may take some time to understand all the features and nuances. One aspect where Haskell differs from the common universal languages is being "lazy". This means Haskell will not do any work unless it needs to be completed. It is as close to assembly language we have had in all of the courses Chapman offers. With learning Haskell, you do not necessarily have to have the most extensive programming experience or knowledge. Haskell is so vastly different from all other languages that it makes it the perfect starting point. Although learning something so different and unique has its advantages, being skilled in mathematics has its benefits to this language. Much of the beginning is understanding and interpreting basic mathematics in different formats. Something as simple as a basic calculator proves its challenges and will make you have an appreciation for everyday programs we use without an extra thought. Since most students taking this course are upperclassmen, that does imply a more extensive understanding than most individuals so we can assume this isn’t our first time learning a new language. Assembly language is vastly different from interpreter languages as one knows, but understanding how the integers and and negative numbers work with different operations will take some time. Firstly, functions are unique in the way they are created. There are multiple classes that must work hand in hand to make a program function correctly. The first assignment for Programming Languages was to create, from a template, a calculator and make our own operations. With a partner we concluded to do our basic 4 mathematical operations and added a couple more, commonly found on a TI-84 calculator. While these other operations, square root, squared, etc. are simple in theory, creating a function that can handle any type of input proves much harder to accomplish. With that out of the way we can dive into the beginning of starting this language. To begin, you should start downloading Haskell by visiting … (insert download link). 

\medskip\noindent
After familiarizing yourself with the UI and paths needed to have interacting classes, a beneficial task to complete would be to go back and understand lambda calculus. A majority of functions will require some knowledge of lambda calculus and understanding it would fast track any issues you run into while coding any mathematical functions in Haskell. 


    \subsection{General Remarks}
    Everything below here is used for template purposes and will not be included in my report in its current form. 
    ~~Work in progress below~~
    
    
     $$x+y=y+x.$$
    
    
    \subsection{Itemize and numbered lists template}
    
    \begin{itemize}
    \item This is how you itemize in LaTeX.
    \begin{enumerate}
    \item \href{https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes}{Learn LaTeX in 30 minutes}
    \item \href{https://www.latex-project.org/}{LaTeX – A document preparation system}\end{enumerate}
    \end{itemize}
    \medskip\noindent
    
    ~~Delete Above L8r~~
    
\section{Haskell}\label{haskell}

    \subsection {Haskell Introduction}
    Learning a new programming language is almost always a steep learning curve. At first it is very difficult to understand and utilize all the nuances of the language. However, this is not the case with Haskell. Unlike every other interpreter language professors use here at Chapman, Haskell is vastly unique and takes a lot more time to fully understand how it works. For instance, Haskell is not an interpreter language, but actually a functional programming language. A bonus to being a functional programming language is the ability to change state whenever you desire. When you run a program in Java or C/C++ a variable must stay consistent when being used in a defined function. This is not the case with Haskell, because you could assign variable ‘x’ to equal 10 in one line then go and change it to say 1 in another line down the program. A topic that was discussed in lecture was the fact that Haskell is a “lazy” programming language. When executing a function you wrote an answer will not be displayed until specifically asked by the user. While typing less in a user created program will theoretically save you time, the adjustment period may prove challenging to experienced programmers. \vskip
    \indent Some changes programmers would have to make when transitioning from an interpreter language to Haskell is learning to unlearn the variable naming convention of most modern interpreters. When using Java, a programmer might type the expression ‘int x = 1+1’. In Haskell there is no need for the expression ‘int’. Haskell is smart enough to deduce a variable is supposed to have an integer value when an equation is opposite the equal sign.  
    
        \subsubsection{Background of Haskell}
        After the creation of the programming language "Miranda" the world wanted to start to venture more into lazy evaluation. The most critical problem with Miranda was the fact it was a proprietary software, not open source for the public to use. In order to utilize this groundbreaking programming software you would have to pay a nice fee to obtain the licence. Just a two year timeline is all it took for a committee to meet and come to the conclusion that an open sourced functional programming language was really needed. The FPCA committee, that met in Portland in 1987, came to the conclusion that a new language, that took into account problems discovered in other languages like Miranda, was to be created.\footnote{\href{https://serokell.io/blog/haskell-history}{Denis Oleynikov, Gints Dreimanis: Haskell. History of a Community-Powered Language}} Most importantly they wanted this software to be free to the public so it was not monopolized by the one percent or big corporations with limitless wealth. Thus in a short time Haskell was born. The creation of Haskell was able to trump the short dynasty of Miranda by becoming an open standard functional programming language, allowing millions of users to suggest and reform properties. 
        
        \vskip With the idea of an open sourced programming language taking form, another ground breaking addition had to introduced. Flashback to around 1925 at Princeton University, Alonzo Church was attending the school. He was an incredible student and graduated in four years with a degree in Mathematics. After finishing his undergrad work Alonzo decided to stay at Princeton and work tirelessly on his post-graduate work. Eventually in around 1935 Alonzo published his work on the topic of Lambda Calculus. The basis for the paper was centered around 'Entscheidungsproblem' a theoretically impossible mathematical and computer science problem. This problem asks for an input that will universally be yes or no. At the time of conception there was no clear answer and stumped researchers for years. While no true, correct answer to the problem exists, Church's findings lead to his development of creating Lambda Calculus.
        
        \vskip Enough time passed and the creation of computers started to take the world by storm. Early programming languages were effective but not up to par with mathematicians standards. Eventually programmers got the idea to utilize Church's work in Lambda Calculus and implement it into a functional programming language. With many different languages existing throughout the world, issues revolving around cross platform inefficacy started to arise. 

\subsection{Types in Haskell}

    \subsubsection{Static Typing}
    As stated earlier, Haskell is a static type system. This means the code will run safer and errors are caught at the instance of compiling, not during execution of actual program. The static typing does not allow a program to run with an error such as an int divided by a string. Furthermore there is no need for variable declaration in Haskell. 
    
    \subsubsection{Typeclasses}
    A new feature to programmers who have familiarized themselves with object oriented programming is typeclasses. These interfaces act as, well an interface, not so much like classes as Java users are comfortable with. These typeclasses act as a definition of a specified behavior and not objects. Some examples of typeclasses are listed below with an example.
    \medskip
    \medskip
    
    
    \caption{Haskell Types by Default}
    \begin{itemize}
              \item Bool - True/False
              \item Char - 'x'
              \item String - 'Haskell'
              \item Int - 500
              \item Double - 5.25864753201772342354689721
              \item Integer - 400250500000
              \item Float - 5.75
    \end{itemize}
    
    There are some important things to note. First, the Bool type represents a single bit of data True or False which can be broken down to the binary equivalent of 1/0. Bool is the smallest bit value possible inside Haskell. Second would be the difference between an Int and an Integer. Ints are integers but have a maximum input of 2147483647. Any natural numbers greater than that will have to be labeled as 'Integer' because they have no maximum. The ability to have no max does impact performance but not enough to cause failures while compiling. The char typeclass consists of any singular character. Meanwhile a string is just a sequence of chars. Strings will obviously take more performance than a char but a string is actually in the typeclass char. The last two differences to discuss would be floats and doubles. They interact in a similar way to the dynamic of Ints and Integers. Both types are decimal numbers but floats can have a maximum of 23 spaces after the decimal point. On the other hand doubles can hold over 23 places passed the decimal but no more than 52, the maximum amount of places a decimal value can be in Haskell \href{PL}{PL}. One more type not listed, but important to note, would be the Eq typeclass. This class is responsible for equality checking in the code. The way this class is represented is with double equal signs '==' or to check if something is not equals, you would type '/='.
            
    
    \subsubsection{Type Inference}
    The interpreter has type inference as well. The auto detection is sophisticated enough to deduce which type is being used in what instance. Most experienced programmers have to tell the IDE what type a variable is when it is declared. Having to unlearn the declaration is difficult because the sheer amount of times it has been done has made it such a habit for most individuals.
    
    \medskip\noindent Now that type inference is understood, its time to see an example. Let's take a look at how Haskell varies from other languages, Java will be the contrasting language in this case.
    \begin{lstlisting}
    --Setting Types in Java--
    int x;
    public timesTwo(){
        x = x + x;
        return x;
    }
    \end{lstlisting}
    
    \medskip
    Java needs the user to tell it what variable types are before manipulating them. The programmer must declare 'x' an integer or else the compiler will have issues trying to figure out whether x is an integer, float, string, etc. This is not the problem with Haskell's type inference.
    
    \begin{lstlisting}
    --Setting Types in Haskell--
    addN :: NN -> NN -> NN
    addN O m = m
    addN (S n) m = S (addN n m)
    \end{lstlisting}
    
    \noindent This example was taken directly from \href{PL}{PL} Assignment 1. Here our group was tasked with implementing a calculator application within Haskell. We were given a template arithmetic file we changed to have operations. The first line does not require a declaration for 'addN' because the other side of the equals sign infers the operation is adding natural numbers. In the final line the code is indicating the computer takes the successor of the declared variable 'n'. This system of programming is different than most modern languages but is, in same ways, more efficient. As you can see, Haskell can require a lot less to complete the same sort of declaration.
    
\subsection{Functions}
    
    \subsubsection{Creating Functions}
    The process of creating a function is not much different than in C/C++ or Java. In one short line you can create a mathematical equation like the one listed below
    
    \begin{lstlisting}
    timesTwo x = x + x 
    \end{lstlisting}
    
    \medskip
    As you can see it is pretty simple. Now creating functions and understanding all the intricacies it has to offer are two completely different things. 
    
    \subsubsection{Curried Functions}
    When creating functions in Haskell, the user created function requires only one parameter, no more and no less. That is the case with most functions but not all. In Haskell we have access to a unique trick called Curried Functions. These functions behave differently than regular define functions because they can take more than one parameter. In reality the functions are only taking in one parameter but the function is nested with other function calls. Each variable is in a specific sequence to complete the desired task. Below is an example of how to code a Curried Function and the command line inputs to execute it. 
    
    \begin{lstlisting}
    --Haskell Code--
    maxNum :: (Ord x) => x -> x -> x 
    
    --Command Line Input--
    gchi> maxNum 5 10 || gchi> (maxNum 5) 10
    10
    \end{lstlisting}
    
    Initially the code is doing a very simple job. The arrows tell the machine to add an x into a function and then added again. Meanwhile in the command line there are a couple different ways to execute this function of finding the max number. The Parenthesis can almost be ignored in these types of functions because the white space and parenthesis act as an operation in itself.
    
    \subsubsection{Lists}
    Something you have created for a trip to the grocery store is present in Haskell. Much like modern languages have implemented, Haskell was ahead of its time when it utilized the list structure. This data structure is homogeneous and can hold a sequence of the same data type. For instance a list can be made up entirely of chars or entirely of Ints. The only restriction is you cannot have two different data types in one list. Lists are defined by square brackets '[]' and each value is separated by a comma. 
    
    \begin{lstlisting}
    gchi> let listEx = [1,2,3,4,5]
    gchi> listEx
    [1,2,3,4,5]
    \end{lstlisting}
    
    Here the 'let' phrase is in charge of naming the list that is being declared. Creating a list is as easy as naming it and inputting what values you desire into the brackets. As long as all the values are the same data type creating a list is quick and efficient way to organize and manipulate data. Another usefulness to list is the ability to combine with like data types. If you have two separate lists that are both Ints or both only contain chars, then you can combine the lists into one using the '++' operation. When combining chars or strings a space will be needed if constructing a phrase. In order to complete this you will need to add double quotes with a white space in between.
    
    \begin{lstlisting}
    ghci> [1,2,3,4,5] ++ [6,7,8,9,10]  
    Output: [1,2,3,4,5,6,7,8,9,10]
    
    gchi> [P,r,o,g,r,a,m,m,i,n,g] ++ " " ++ [L,a,n,g,u,a,g,e,s]
    Output: Programming Languages
    \end{lstlisting}
    
    Lists inside Haskell are simple to create, manipulate and can be very useful to a programmer if utilized to the best of their ability. A fun key feature with lists that any programmer can use is indexing. Indexing can be done with a string but mainly inside a list to find a specific value. The way to index a value is very simple; First you enter the list, string, integer, etc. followed by double exclamation points, lastly followed by what index you want to search. An example of how to accomplish this is below. 
    
    \begin{lstlisting}
    gchi> let sampleList = [1,3,5,7,9]
    ghci> sampleList !! 1
    Output: 3
    \end{lstlisting}
    
    Indexing is a valuable skill to learn whether it be for finding certain data values or replacing/adding values into a list. As important as indexing is, there are quite a few more commands that can manipulate lists in Haskell. Here are some more to familiarize yourself with.
    
    \medskip\medskip
    \caption{Haskell List Commands}
    \begin{itemize}
              \item head [...] - returns the first element within a list
              \item last [...] - returns the last element in a list
              \item length [...] - outputs the length of a list based on how many elements are inside
              \item drop # [...] - staring from index 0, start of list, drops the number of elements inputted from list
              \item maximum [...] - outputs the largest value within a list
              \item minimum [...] - outputs the smallest value within a list
              \item sum [...] - takes all integers in a list and returns the summation, cannot work with strings
    \end{itemize}
    
    \medskip
    \noindent Obviously this is not the full extent of all the commands possible but these are a great starting point if you are learning Haskell for the first time. 
    
    

\section{Programming Languages Theory}

In this section you will show what you learned about the theory of programming languages. ...
    \subsection{Lambda Calculus}
    ...

\section{Project}

Projects in Haskell are much more intensive and require more time to accomplish the task you wish to complete. The biggest piece of advice I suggest would be it is okay to not get it immediately. Haskell is great for new open minded individuals but experienced programmers might struggle to switch gears into this new world. Baseball players struggle to hit golf balls because the swing is so different and it is the exact same concept here. 

\section{Conclusions}\label{conclusions}

So in conclusion we have gone over quite a bit of subjects regarding Haskell and its basics to understand completely before undertaking an assignment of your own. While having previous knowledge and experience is usually a benefit to your cause, Haskell might put that notion to the test. Something as simple as adding positive numbers can cause so many problems to programmers' complicated structured brains. 

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2021/blob/main/README.md}{Programming Languages 2021}, Chapman University, 2021.

\bibitem[serokell.io]{https://serokell.io/blog/haskell-history}
\href{https://serokell.io/blog/haskell-history}{History of a Community-Powered Language}

\end{thebibliography}

\end{document}





